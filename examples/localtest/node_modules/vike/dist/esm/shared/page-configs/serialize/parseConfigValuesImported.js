export { parseConfigValuesImported };
import { assert } from '../../utils.js';
import { assertExportsOfValueFile } from '../assertExports.js';
function parseConfigValuesImported(configValuesImported) {
    const configValues = {};
    const addConfigValue = (configName, value, importPath, exportName) => {
        configValues[configName] = {
            value,
            definedAt: {
                // importPath cannot be relative to the current file, since the current file is a virtual file
                filePathToShowToUser: importPath,
                fileExportPathToShowToUser: [configName, 'default'].includes(exportName)
                    ? []
                    : // Side-effect config
                        [exportName]
            }
        };
        assertIsNotNull(value, configName, importPath);
    };
    configValuesImported.forEach((configValueLoaded) => {
        if (configValueLoaded.isValueFile) {
            const { exportValues, importPath, configName } = configValueLoaded;
            if (configName !== 'client') {
                assertExportsOfValueFile(exportValues, importPath, configName);
            }
            Object.entries(exportValues).forEach(([exportName, exportValue]) => {
                const isSideExport = exportName !== 'default'; // .md files may have "side-exports" such as `export { frontmatter }`
                const configName = isSideExport ? exportName : configValueLoaded.configName;
                if (isSideExport && configName in configValues) {
                    // We can't avoid side-export conflicts upstream. (Because we cannot know about side-exports upstream at build-time.)
                    // Side-exports have the lowest priority.
                    return;
                }
                addConfigValue(configName, exportValue, importPath, exportName);
            });
        }
        else {
            const { configName, importPath, exportValue, exportName } = configValueLoaded;
            addConfigValue(configName, exportValue, importPath, exportName);
        }
    });
    return configValues;
}
function assertIsNotNull(configValue, configName, importPath) {
    assert(!importPath.includes('+config.'));
    /* Re-use this for:
     *  - upcoming config.requestPageContextOnNavigation
     *  - for cumulative values in the future: we don't need this for now because, currently, cumulative values are never imported.
    assertUsage(
      configValue !== null,
      `Set ${pc.cyan(configName)} to ${pc.cyan('null')} in a +config.h.js file instead of ${importPath}`
    )
    */
}
