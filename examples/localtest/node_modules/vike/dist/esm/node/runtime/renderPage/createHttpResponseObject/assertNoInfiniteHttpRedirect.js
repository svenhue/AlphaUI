export { assertNoInfiniteHttpRedirect };
import { assert, assertUsage, getGlobalObject, isUriWithProtocol } from '../../utils.js';
import pc from '@brillout/picocolors';
const globalObject = getGlobalObject('assertNoInfiniteHttpRedirect.ts', {
    redirectGraph: {}
});
function assertNoInfiniteHttpRedirect(urlRedirectTarget, urlLogical) {
    if (isUriWithProtocol(urlRedirectTarget)) {
        // We assume that urlRedirectTarget points to an origin that is external (not the same origin), and we can therefore assume that the app doesn't define an infinite loop (in itself).
        //  - There isn't a reliable way to check whether the redirect points to an external origin or the same origin. For same origins, we assume/hope the user to pass the URL without origin.
        //    ```js
        //    // For same-origin, the user usually/hopefully passes a URL without origin
        //    renderPage({ urlOriginal: '/some/pathname' })
        //    ```
        return;
    }
    assert(urlRedirectTarget.startsWith('/'));
    assert(urlLogical.startsWith('/'));
    const graph = copy(globalObject.redirectGraph);
    graph[urlRedirectTarget] ?? (graph[urlRedirectTarget] = new Set());
    graph[urlRedirectTarget].add(urlLogical);
    validate(graph);
    globalObject.redirectGraph = graph;
}
function copy(G) {
    return Object.fromEntries(Object.entries(G).map(([key, val]) => [key, new Set(val)]));
}
// Adapted from: https://stackoverflow.com/questions/60904464/detect-cycle-in-directed-graph/60907076#60907076
function validate(G) {
    Object.keys(G).forEach((n) => check(G, n, []));
}
function check(G, n, path) {
    if (path.includes(n)) {
        const cycle = path.slice(path.indexOf(n)).concat(n);
        assertUsage(false, `Infinite loop of HTTP URL redirects: ${cycle.map(pc.cyan).join(' -> ')}`);
    }
    G[n]?.forEach((node) => check(G, node, [...path, n]));
}
