"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findImportBuildBundleEntry = exports.importBuild = void 0;
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const importBuildFileName_1 = require("../shared/importBuildFileName");
const debugLogs_1 = require("../shared/debugLogs");
const importBuildPromise_1 = require("../loadServerBuild/importBuildPromise");
const autoImporterFilePath = require.resolve('../autoImporter');
const inputName = 'importBuild';
const importBuildVirtualId = 'virtual:@brillout/vite-plugin-import-build:importBuild';
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
const virtualIdPrefix = '\0';
const apiVersion = 2;
/**
 * The Vite plugin `importBuild()` does two things:
 *  - Generates an "import build" file at `dist/server/importBuild.cjs`.
 *  - Generates an "auto importer" file at `node_modules/@brillout/vite-plugin-import-build/dist/autoImporter.js`.
 *
 * See https://github.com/brillout/vite-plugin-import-build#what-it-does for more information.
 */
function importBuild(pluginConfigProvidedByLibrary) {
    let config;
    let serverEntryFilePath;
    let library;
    let skip;
    let injectDone = false;
    return {
        name: `@brillout/vite-plugin-import-build:${pluginConfigProvidedByLibrary.libraryName.toLowerCase()}`,
        apply: 'build',
        configResolved(configUnresolved) {
            // Upon the server-side build (`$ vite build --ssr`), we need to override the previous `skip` value set by the client-side build (`$ vite build`).
            skip = !(0, utils_1.viteIsSSR)(configUnresolved);
            if (skip)
                return;
            const resolved = resolveConfig(configUnresolved, pluginConfigProvidedByLibrary);
            config = resolved.config;
            library = resolved.library;
            // We can't use isLeader() for the following but it's fine: running the following multiple times isn't a problem.
            config.build.rollupOptions.input = (0, utils_1.injectRollupInputs)({ [inputName]: importBuildVirtualId }, config);
        },
        buildStart() {
            if (skip)
                return;
            if (!isLeaderPluginInstance(config, library)) {
                skip = true;
                return;
            }
            serverEntryFilePath = config._vitePluginImportBuild.inject ? getServerEntryFilePath(config) : null;
            assertApiVersions(config, pluginConfigProvidedByLibrary.libraryName);
            clearAutoImporterFile({ status: 'RESET' });
        },
        resolveId(id) {
            if (skip)
                return;
            if (id === importBuildVirtualId) {
                return virtualIdPrefix + importBuildVirtualId;
            }
        },
        load(id) {
            if (skip)
                return;
            (0, utils_1.assert)(id !== importBuildVirtualId);
            if (id === virtualIdPrefix + importBuildVirtualId) {
                const importBuildFileContent = getImportBuildFileContent(config);
                return importBuildFileContent;
            }
        },
        generateBundle(_rollupOptions, bundle) {
            if (skip)
                return;
            if (config._vitePluginImportBuild.inject) {
                (0, utils_1.assert)(injectDone);
            }
            // Write node_modules/@brillout/vite-plugin-import-build/dist/autoImporter.js
            const { testCrawler } = config._vitePluginImportBuild;
            const doNotAutoImport = config._vitePluginImportBuild.inject || (0, utils_1.isYarnPnP)() || testCrawler;
            if (!doNotAutoImport) {
                writeAutoImporterFile(config);
            }
            else {
                const status = testCrawler ? 'TEST_CRAWLER' : 'DISABLED';
                clearAutoImporterFile({ status });
                (0, debugLogs_1.debugLogsBuildtime)({ disabled: true, paths: null });
            }
            // Write dist/server/importBuild.cjs (legacy/deprecated entry file name)
            // TODO: add deprecation warning
            {
                const fileName = 'importBuild.cjs';
                const fileNameActual = (0, utils_1.findRollupBundleEntry)(inputName, bundle).fileName;
                if (fileNameActual !== fileName)
                    this.emitFile({
                        fileName,
                        type: 'asset',
                        source: `globalThis.${importBuildPromise_1.importBuildPromise} = import('./${fileNameActual}')`
                    });
            }
        },
        transform(code, id) {
            if (skip)
                return;
            if (!config._vitePluginImportBuild.inject)
                return;
            (0, utils_1.assert)(serverEntryFilePath);
            if (id !== serverEntryFilePath)
                return;
            {
                const moduleInfo = this.getModuleInfo(id);
                (0, utils_1.assert)(moduleInfo?.isEntry);
            }
            injectDone = true;
            code = [
                // Convenience so that the user doesn't have to set manually set it, while the user can easily override it (this is the very first line of the server code).
                "process.env.NODE_ENV = 'production';",
                // Imports the entry of each tool, e.g. the Vike entry and the Telefunc entry.
                `import '${importBuildVirtualId}';`,
                code
            ].join(''
            /* We don't insert new lines, otherwise we break the source map.
            '\n'
            */
            );
            return code;
        }
    };
}
exports.importBuild = importBuild;
function resolveConfig(configUnresolved, pluginConfigProvidedByLibrary) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(configUnresolved));
    const pluginConfigProvidedByUser = configUnresolved.vitePluginImportBuild;
    const pluginConfigResolved = configUnresolved._vitePluginImportBuild ?? {
        libraries: [],
        apiVersion,
        testCrawler: false,
        inject: false
    };
    if (pluginConfigProvidedByLibrary.inject) {
        pluginConfigResolved.inject = true;
    }
    if (pluginConfigProvidedByUser?._testCrawler) {
        pluginConfigResolved.testCrawler = true;
    }
    // @ts-expect-error workaround for previously broken api version assertion
    pluginConfigResolved.configVersion = 1;
    const library = {
        getImporterCode: pluginConfigProvidedByLibrary.getImporterCode,
        libraryName: pluginConfigProvidedByLibrary.libraryName,
        vitePluginImportBuildVersion: utils_1.projectInfo.projectVersion,
        apiVersion
    };
    pluginConfigResolved.libraries.push(library);
    (0, utils_1.objectAssign)(configUnresolved, {
        _vitePluginImportBuild: pluginConfigResolved
    });
    const config = configUnresolved;
    return { config, library };
}
function isLeaderPluginInstance(config, library) {
    const { libraries } = config._vitePluginImportBuild;
    const pluginVersion = utils_1.projectInfo.projectVersion;
    (0, utils_1.assert)(libraries.includes(library));
    const isNotUsingNewestPluginVersion = libraries.some((lib) => {
        // Can be undefined when set by an older @brillout/vite-plugin-import-build version
        if (!lib.vitePluginImportBuildVersion)
            return false;
        return isHigherVersion(lib.vitePluginImportBuildVersion, pluginVersion);
    });
    if (isNotUsingNewestPluginVersion)
        return false;
    const librariesUsingNewestPluginVersion = libraries.filter((lib) => lib.vitePluginImportBuildVersion === pluginVersion);
    return librariesUsingNewestPluginVersion[0] === library;
}
function getImportBuildFileContent(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const importBuildFileContent = [
        '// Generated by https://github.com/brillout/vite-plugin-import-build',
        ...config._vitePluginImportBuild.libraries.map((library) => {
            // Should be true becasue of assertApiVersions()
            (0, utils_1.assert)(getLibraryApiVersion(library) === apiVersion);
            const entryCode = library.getImporterCode();
            return entryCode;
        })
    ].join('\n');
    return importBuildFileContent;
}
function writeAutoImporterFile(config) {
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config);
    const importBuildFilePathRelative = path_1.default.posix.join(distServerPathRelative, importBuildFileName_1.importBuildFileName);
    const importBuildFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, importBuildFileName_1.importBuildFileName);
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)(!(0, utils_1.isYarnPnP)());
    (0, fs_1.writeFileSync)(autoImporterFilePath, [
        "exports.status = 'SET';",
        `exports.loadImportBuild = () => { require(${JSON.stringify(importBuildFilePathRelative)}) };`,
        'exports.paths = {',
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePath)},`,
        '  autoImporterFileDirActual: (() => { try { return __dirname } catch { return null } })(),',
        `  importBuildFilePathRelative: ${JSON.stringify(importBuildFilePathRelative)},`,
        `  importBuildFilePathOriginal: ${JSON.stringify(importBuildFilePathAbsolute)},`,
        `  importBuildFilePathResolved: () => require.resolve(${JSON.stringify(importBuildFilePathRelative)}),`,
        '};',
        // Support old version vite-plugin-import-build@0.1.12 which is needed, e.g. if user uses a Telefunc version using 0.1.12 with a vite-plugin-ssr version using 0.2.0
        `exports.load = exports.loadImportBuild;`,
        ''
    ].join('\n'));
}
function clearAutoImporterFile(autoImporter) {
    if ((0, utils_1.isYarnPnP)())
        return;
    (0, fs_1.writeFileSync)(autoImporterFilePath, [`exports.status = '${autoImporter.status}';`, ''].join('\n'));
}
/** Is `semver1` higher than `semver2`?*/
function isHigherVersion(semver1, semver2) {
    const parsed1 = parseSemver(semver1);
    const parsed2 = parseSemver(semver2);
    for (let i = 0; i <= parsed1.parts.length - 1; i++) {
        if (parsed1.parts[i] !== parsed2.parts[i]) {
            return parsed1.parts[i] > parsed2.parts[i];
        }
    }
    if (parsed1.isPreRelease !== parsed2.isPreRelease) {
        return parsed1.isPreRelease;
    }
    return false;
}
function parseSemver(semver) {
    let isPreRelease = false;
    if (semver.includes('-')) {
        isPreRelease = true;
        semver = semver.split('-')[0]; // '0.2.16-commit-89bbe89' => '0.2.16'
    }
    (0, utils_1.assert)(/^[0-9\.]+$/.test(semver));
    const partsStr = semver.split('.');
    (0, utils_1.assert)(partsStr.length === 3);
    const parts = partsStr.map((n) => parseInt(n, 10));
    return { parts, isPreRelease };
}
function getDistServerPathRelative(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)((0, utils_1.isAbsolutePath)(root));
    const importerDir = getImporterDir();
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let { outDir } = config.build;
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_1.toPosixPath)(outDir);
    if ((0, utils_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_1.assert)(!(0, utils_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogs_1.debugLogsBuildtime)({
        disabled: false,
        paths: { importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute }
    });
    return { distServerPathRelative, distServerPathAbsolute };
}
function getImporterDir() {
    const currentDir = (0, utils_1.toPosixPath)(__dirname + (() => '')()); // trick to avoid `@vercel/ncc` to glob import
    return path_1.default.posix.join(currentDir, '..');
}
function assertApiVersions(config, currentLibraryName) {
    const librariesNeedingUpdate = [];
    // Very old versions used to define config.vitePluginDistImporter
    if ('vitePluginDistImporter' in config) {
        const dataOld = config.vitePluginDistImporter;
        dataOld.libraries.forEach((lib) => {
            (0, utils_1.assert)(lib.libraryName);
            librariesNeedingUpdate.push(lib.libraryName);
        });
    }
    const pluginConfigResolved = config._vitePluginImportBuild;
    pluginConfigResolved.libraries.forEach((library) => {
        const apiVersionLib = getLibraryApiVersion(library);
        if (apiVersionLib < apiVersion) {
            librariesNeedingUpdate.push(library.libraryName);
        }
        else {
            // Should be true because of isUsingOlderVitePluginImportBuildVersion() call above
            (0, utils_1.assert)(apiVersionLib === apiVersion);
        }
    });
    if (librariesNeedingUpdate.length > 0) {
        const libs = (0, utils_1.joinEnglish)(librariesNeedingUpdate, 'and');
        // We purposely use `throw new Error()` instead of `assertUsage()`, in order to not confuse the user with superfluous information
        throw new Error(`Update ${libs} to its latest version and try again: ${currentLibraryName} requires a newer version of ${libs}.`);
    }
}
function getLibraryApiVersion(library) {
    // library.apiVersion can be undefined when set by an older @brillout/vite-plugin-import-build version
    const apiVersionLib = library.apiVersion ?? 1;
    return apiVersionLib;
}
function findImportBuildBundleEntry(bundle /*, options: Options*/) {
    return (0, utils_1.findRollupBundleEntry)(inputName, bundle);
}
exports.findImportBuildBundleEntry = findImportBuildBundleEntry;
function getServerEntryFilePath(config) {
    const entries = (0, utils_1.normalizeRollupInput)(config.build.rollupOptions.input);
    const entryName = 'index';
    let serverEntryFilePath = entries[entryName];
    if (!serverEntryFilePath) {
        const entryNames = Object.keys(entries)
            .map((e) => `'${e}'`)
            .join(', ');
        (0, utils_1.assertUsage)(false, `Cannot find server build entry '${entryName}'. Make sure your Rollup config doesn't remove the entry '${entryName}' of your server build ${config.build.outDir}. (Found server build entries: [${entryNames}].)`);
    }
    serverEntryFilePath = require.resolve(serverEntryFilePath);
    // Needs to be absolute, otherwise it won't match the `id` in `transform(id)`
    (0, utils_1.assert)(path_1.default.isAbsolute(serverEntryFilePath));
    serverEntryFilePath = (0, utils_1.toPosixPath)(serverEntryFilePath);
    return serverEntryFilePath;
}
